#include "map_builder.h"
#include "../common_utils.h"
#include <chrono>
#include <cstring>
#include <iostream>
#include <quakelib/bsp/qbsp_provider.h>
#include <quakelib/map/lightmap_generator.h>
#include <quakelib/map/qmap_provider.h>
#include <quakelib/wad/wad.h>
#include <raymath.h>
#include <rlgl.h>

MapBuilder::MapBuilder(AssetManager &assetMgr, const QuakeMapOptions &opts)
    : assetMgr(assetMgr), opts(opts) {}

GeneratedMapData MapBuilder::Build(quakelib::IMapProviderPtr provider) {
  GeneratedMapData data;
  using Clock = std::chrono::high_resolution_clock;
  using ms = std::chrono::milliseconds;

  auto t_parse_start = Clock::now();

  // Map is already loaded and geometry generated by Scene

  // NOTE: Face types are now configured in Scene before calling Build

  auto t_parse_end = Clock::now();

  // Geometry is already generated by Scene calling provider->GenerateGeometry()

  auto t_geo_end = Clock::now();
  auto t_lm_start = Clock::now();

  // Lightmap Generation (Only if QMap for now, BSP support later)
  data.lightmapAtlas = generateLightmapAtlas(provider);

  auto t_lm_end = Clock::now();

  // Stats (some stats meaningless now as work is distributed)
  long long t_lm = std::chrono::duration_cast<ms>(t_lm_end - t_lm_start).count();

  std::cout << "--------------------------------\n"
            << "Map Compilation/Loading Stats:\n"
            << " Lightmap Bake: " << t_lm << " ms\n"
            << "--------------------------------" << std::endl;

  // Convert entities to models
  for (const auto &se : provider->GetSolidEntities()) {
    auto m = readModelEntity(provider, se);
    // Only add if it has meshes
    if (m.model.meshCount > 0) {
      data.models.push_back(m);

      // Print vertex count for worldspawn
      if (se->ClassName() == "worldspawn") {
        int totalVertices = 0;
        for (int i = 0; i < m.model.meshCount; i++) {
          totalVertices += m.model.meshes[i].vertexCount;
        }
        std::cout << "Worldspawn vertex count: " << totalVertices << std::endl;
      }
    }
  }

  // Player Start (Generic Point Entity API needed? Or cast?)
  // For now using point entities list
  auto pointEnts = provider->GetPointEntities();
  for (const auto &pe : pointEnts) {
    if (pe->ClassName() == "info_player_start") {
      data.playerStart = pe;
      break;
    }
  }

  data.textureNames = provider->GetTextureNames();

  return data;
}

Texture2D MapBuilder::generateLightmapAtlas(quakelib::IMapProviderPtr provider) {
  // Check if provider has existing lightmap (typical for BSP)
  auto existingLm = provider->GetLightmapData();
  if (existingLm) {
    Image img;
    img.data = RL_MALLOC(existingLm->data.size());
    memcpy(img.data, existingLm->data.data(), existingLm->data.size());
    img.width = existingLm->width;
    img.height = existingLm->height;
    img.mipmaps = 1;
    img.format = PIXELFORMAT_UNCOMPRESSED_R8G8B8A8;

    Texture2D tex = LoadTextureFromImage(img);
    UnloadImage(img);
    SetTextureFilter(tex, TEXTURE_FILTER_BILINEAR);
    return tex;
  }

  // Try to cast to QMapProvider to access underlying QMap (if needed for LightmapGenerator)
  // Or handle generically. LightmapGenerator uses SolidEntityPtr (generic shared ptr?).
  // Let's assume LightmapGenerator works with base SolidEntity if it exposes brushes (it does not for generic
  // Entity). Actually LightmapGenerator is specific to QMap brushes.

  auto qmap = std::dynamic_pointer_cast<quakelib::QMapProvider>(provider);
  if (!qmap) {
    // BSP or other. Returning white stub for now.
    // In future BSP provider can expose existing lightmap.
    Image whiteImg = GenImageColor(4, 4, WHITE);
    Texture2D tex = LoadTextureFromImage(whiteImg);
    UnloadImage(whiteImg);
    return tex;
  }

  // If we are here, we are using QMapProvider, so we can try to use existing QMap logic?
  // But QMapProvider encapsulates QMap. We need access to SolidEntities.
  // QMapProvider::GetSolidEntities() returns std::vector<SolidEntityPtr> (generic).
  // LightmapGenerator::Pack expects vector<map::SolidEntityPtr> (impl-specific).

  // Simpler approach: Dynamic cast items.
  quakelib::map::LightmapGenerator lmGen(2048, 2048);
  std::vector<quakelib::map::SolidEntityPtr> allSolids;

  for (const auto &se : provider->GetSolidEntities()) {
    auto casted = std::dynamic_pointer_cast<quakelib::map::SolidMapEntity>(se);
    if (casted)
      allSolids.push_back(casted);
  }

  // From here logic is similar
  if (!lmGen.Pack(allSolids)) {
    std::cerr << "Failed to pack lightmaps! Using default white." << std::endl;
    Image whiteImg = GenImageColor(4, 4, WHITE);
    Texture2D tex = LoadTextureFromImage(whiteImg);
    UnloadImage(whiteImg);
    return tex;
  }

  std::cout << "Lightmap Atlas Generated: " << lmGen.GetWidth() << "x" << lmGen.GetHeight() << std::endl;

  std::vector<quakelib::map::LightmapGenerator::Light> lights;

  for (const auto &pe : provider->GetPointEntities()) {
    if (pe->ClassName() == "light") {
      float r = pe->AttributeFloat("light");
      if (r <= 1.0f)
        r = 300.0f;

      fvec3 color = {1.0f, 1.0f, 1.0f};
      if (pe->Attributes().count("_color")) {
        color = pe->AttributeVec3("_color");
      } else if (pe->Attributes().count("color")) {
        color = pe->AttributeVec3("color");
      }

      // Normalize color if it's 0-255
      if (color[0] > 1.0f || color[1] > 1.0f || color[2] > 1.0f) {
        color[0] /= 255.0f;
        color[1] /= 255.0f;
        color[2] /= 255.0f;
      }
      lights.push_back({pe->Origin(), r, color});
    }
  }

  fvec3 ambient = {0.3f, 0.3f, 0.3f};
  auto solids = provider->GetSolidEntities();
  auto worldspawn = solids.empty() ? nullptr : solids[0];
  if (worldspawn && worldspawn->ClassName() == "worldspawn") {
    if (worldspawn->Attributes().count("ambient")) {
      float a = worldspawn->AttributeFloat("ambient");
      ambient = {a / 255.0f, a / 255.0f, a / 255.0f};
    }
  }

  std::cout << "Baking " << lights.size() << " lights..." << std::endl;
  lmGen.CalculateLighting(lights, ambient);

  Image atlasImg;
  atlasImg.data = (void *)lmGen.GetAtlasData().data();
  atlasImg.width = lmGen.GetWidth();
  atlasImg.height = lmGen.GetHeight();
  atlasImg.format = PIXELFORMAT_UNCOMPRESSED_R8G8B8A8;
  atlasImg.mipmaps = 1;

  Texture2D lightmapAtlas = LoadTextureFromImage(atlasImg);
  SetTextureFilter(lightmapAtlas, TEXTURE_FILTER_BILINEAR);
  return lightmapAtlas;
}

QuakeModel MapBuilder::readModelEntity(quakelib::IMapProviderPtr provider,
                                       const quakelib::SolidEntityPtr &ent) {
  QuakeModel qm;

  auto meshes = provider->GetEntityMeshes(ent);

  for (const auto &mesh : meshes) {
    if (mesh.vertices.empty())
      continue;

    // Check type
    if (mesh.type == quakelib::SurfaceType::CLIP || mesh.type == quakelib::SurfaceType::SKIP ||
        mesh.type == quakelib::SurfaceType::NODRAW)
      continue;

    auto rayMesh = Mesh{0};
    rayMesh.triangleCount = mesh.indices.size() / 3;
    rayMesh.vertexCount = mesh.vertices.size();

    rayMesh.vertices = (float *)MemAlloc(rayMesh.vertexCount * 3 * sizeof(float));
    rayMesh.tangents = (float *)MemAlloc(rayMesh.vertexCount * 4 * sizeof(float));
    rayMesh.texcoords = (float *)MemAlloc(rayMesh.vertexCount * 2 * sizeof(float));
    rayMesh.texcoords2 = (float *)MemAlloc(rayMesh.vertexCount * 2 * sizeof(float));
    rayMesh.normals = (float *)MemAlloc(rayMesh.vertexCount * 3 * sizeof(float));
    rayMesh.colors = (unsigned char *)MemAlloc(rayMesh.vertexCount * 4 * sizeof(unsigned char));

    // We must invoke indices allocation even if we populate manually?
    // Raylib UploadMesh handles indices if provided.
    rayMesh.indices = (unsigned short *)MemAlloc(mesh.indices.size() * sizeof(unsigned short));

    unsigned char baryColors[3][4] = {{255, 0, 0, 255}, {0, 255, 0, 255}, {0, 0, 255, 255}};

    // Copy data
    for (int i = 0; i < mesh.vertices.size(); ++i) {
      // Coordinate conversion: Z-up to Y-up
      rayMesh.vertices[i * 3 + 0] = -mesh.vertices[i].point[0] / opts.inverseScale;
      rayMesh.vertices[i * 3 + 1] = mesh.vertices[i].point[2] / opts.inverseScale;
      rayMesh.vertices[i * 3 + 2] = mesh.vertices[i].point[1] / opts.inverseScale;

      rayMesh.normals[i * 3 + 0] = -mesh.vertices[i].normal[0];
      rayMesh.normals[i * 3 + 1] = mesh.vertices[i].normal[2];
      rayMesh.normals[i * 3 + 2] = mesh.vertices[i].normal[1];

      // Tangents
      rayMesh.tangents[i * 4 + 0] = -mesh.vertices[i].tangent[0];
      rayMesh.tangents[i * 4 + 1] = mesh.vertices[i].tangent[2];
      rayMesh.tangents[i * 4 + 2] = mesh.vertices[i].tangent[1];
      rayMesh.tangents[i * 4 + 3] = 1.0f;

      rayMesh.texcoords[i * 2 + 0] = mesh.vertices[i].uv[0];
      rayMesh.texcoords[i * 2 + 1] = mesh.vertices[i].uv[1];

      rayMesh.texcoords2[i * 2 + 0] = mesh.vertices[i].lightmap_uv[0];
      rayMesh.texcoords2[i * 2 + 1] = mesh.vertices[i].lightmap_uv[1];

      // Barycentric colors for debugging
      int triIndex = i % 3;
      rayMesh.colors[i * 4 + 0] = baryColors[triIndex][0];
      rayMesh.colors[i * 4 + 1] = baryColors[triIndex][1];
      rayMesh.colors[i * 4 + 2] = baryColors[triIndex][2];
      rayMesh.colors[i * 4 + 3] = baryColors[triIndex][3];
    }

    for (int i = 0; i < mesh.indices.size(); ++i) {
      rayMesh.indices[i] = (unsigned short)mesh.indices[i];
    }

    // Need to re-order indices for winding order?
    // Original code: int idx[3] = {(int)indices[k + 2], (int)indices[k + 1], (int)indices[k]};
    // The provider returns indices in standard order (0,1,2).
    // If we swapped Y/Z and X=-X, winding order flips.
    // So we probably need to swap indices 0 and 2 of every triangle.

    for (int i = 0; i < mesh.indices.size(); i += 3) {
      std::swap(rayMesh.indices[i], rayMesh.indices[i + 2]);
    }

    UploadMesh(&rayMesh, false);
    qm.meshes.push_back(rayMesh);

    // We need to find global texture ID?
    // RenderMesh has textureName.
    // GeneratedMapData.textureNames has list.
    // We need to map Name -> Index.
    auto names = provider->GetTextureNames();
    auto it = std::find(names.begin(), names.end(), mesh.textureName);
    int matID = 0;
    if (it != names.end()) {
      matID = std::distance(names.begin(), it);
    }
    qm.materialIDs.push_back(matID);
  }

  // ... rest of setup ...

  qm.model.transform = MatrixIdentity();
  qm.model.meshCount = qm.meshes.size();
  qm.model.meshes = (Mesh *)MemAlloc(qm.model.meshCount * sizeof(Mesh));
  qm.model.meshMaterial = (int *)MemAlloc(qm.model.meshCount * sizeof(int));

  for (int m = 0; m < qm.meshes.size(); m++) {
    qm.model.meshes[m] = qm.meshes[m];
    qm.model.meshMaterial[m] = qm.materialIDs[m];
  }

  return qm;
}
